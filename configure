#!/usr/bin/env python

"""Configure the project for building.

Supports Linux, BSD, Mac, Windows and tries to be POSIX compliant (except on
Windows)
"""

import argparse
import collections
import codecs
import fnmatch
import os
import itertools
from os import path
import re
import shutil
from tempfile import mkdtemp

_project = "libchirp"
_version = "0.1.0"

_base = path.dirname(path.realpath(__file__))
_baselen = len(_base)
_include = re.compile('^\s*#\s*include\s*"\s*([^"]+\s*).*$')


def match_files(base, pattern):
    """Match files in a base path."""
    for root, dirnames, filenames in os.walk(
            path.join(_base, base)
    ):
        for filename in fnmatch.filter(filenames, pattern):
            yield path.join(root, filename)


def parse_depends(file_, h_files):
    """Find all header depends in this files."""
    with codecs.open(file_, 'r', "UTF-8") as f:
        for line in f:
            match = _include.match(line)
            if match:
                header = match[1]
                base = path.dirname(
                    path.realpath(file_)
                )
                if _project in header:
                    depend = path.realpath(
                        path.join(_base, "include", header)
                    )
                else:
                    depend = path.realpath(
                        path.join(base, header)
                    )
                if depend in h_files:
                    yield depend


def flat_depends(file_, depends, flat):
    """Create a flat depends list of recursive dependencies."""
    if file_  not in flat:
        dep = depends[file_]
        if not dep:
            return flat
        for rec in dep:
            flat.add(rec)
            flat_depends(rec, depends, flat)
    return flat


def read_depends():
    """Read header dependencies into a dict to generate the makefile."""
    depends = collections.defaultdict(set)
    c_files = set(match_files("src", "*.c"))
    h_files = set()
    h_files.update(match_files("src", "*.h"))
    h_files.update(match_files("include", "*.h"))
    for file_ in itertools.chain(c_files, h_files):
        for depend in parse_depends(file_, h_files):
            depends[file_].add(depend)
    dependency_list = {file_: flat_depends(
        file_,
        depends,
        set()
    ) for file_ in c_files}
    return dependency_list


def replace_base(file_):
    """Replace the base path with $(BASE)."""
    if file_.startswith(_base):
        return "$(BASE)%s" % file_[_baselen:]
    else:
        return file_


def test_depends():
    """Test for dependencies."""
    if os.system("make testlibuv"):
        print("""libuv was not found. For details see config.log

Please install libuv:

Alpine:         apk add libuv-dev
Debian-based:   apt install libuv1-dev (may require backports)
Redhat-based:   yum install libuv-devel
Arch:           pacman -S libuv
OSX:            brew install libuv
""")
    if os.system("make testopenssl"):
        print("""openssl was not found. For details see config.log

Please install openssl:

Alpine:         apk add openssl-dev
Debian-based:   apt install libssl-dev
Redhat-based:   yum install openssl-devel
Arch:           pacman -S openssl
OSX:            brew install openssl
""")


def write_makefile():
    """Parse arguments and write makefile accordingly."""
    parser = argparse.ArgumentParser(
        description='Configure %s' % _project
    )
    parser.add_argument(
        '--dev',
        action="store_true",
        help=(
            "Build for development. Enables debug build flags and coverage. "
            "Includes all development make targets."
        )
    )
    parser.add_argument(
        '--prefix',
        help="Install prefix. Default: /usr/local"
    )

    args = parser.parse_args()
    prefix = "/usr/local"
    if args.prefix:
        prefix = args.prefix
    with codecs.open("Makefile", "w", "UTF-8") as f:
        f.write("BASE := %s\n" % _base)
        f.write("PREFIX := %s\n" % prefix)
        f.write("DTMP := %s\n\n" % mkdtemp())
        f.write("PROJECT := %s\n" % _project)
        f.write("VERSION := %s\n" % _version)
        f.write("MAJOR := %s\n\n" % _version.split('.')[0])
        f.write("include $(BASE)/mk/base.mk\n")
        if args.dev:
            f.write("include $(BASE)/mk/dev.mk\n\n")
        else:
            f.write("include $(BASE)/mk/rel.mk\n\n")
        if args.dev:
            depends = list(read_depends().items())
        else:
            depends = [
                (
                    key, value
                ) for key, value in read_depends().items()
                if not key.endswith("test.c")
            ]
        f.write("libraries: {0}.a {0}.so\n\n".format(_project))
        if args.dev:
            f.write("executables: \\\n")
            executables = [
                (
                    key, value
                ) for key, value in depends
                if key.endswith("_etest.c")
            ]
            for executable, _ in executables[:-1]:
                f.write("\t\t%s \\\n" % replace_base(executable[:-2]))
            f.write("\t\t%s \n\n" % replace_base(executables[-1][0][:-2]))
        f.write("objects: \\\n")
        for file_, _ in depends[:-1]:
            f.write("\t\t%so \\\n" % replace_base(file_[:-1]))
        f.write("\t\t%so \n\n" % replace_base(depends[-1][0][:-1]))

        for file_, dep in depends:
            if dep:
                dep = list(dep)
                f.write("%s: \\\n" % replace_base(file_))
                for depend in dep[:-1]:
                    f.write("\t\t%s \\\n" % replace_base(depend))
                f.write("\t\t%s \n\n" % replace_base(dep[-1]))
    try:
        os.unlink(path.join(_base, "config.h"))
    except Exception:
        pass
    print("Created Makefile. It contains sensible defaults.")
    shutil.copy(
        path.join(_base, "mk", "config.defs.h"),
        "config.h"
    )
    print("Created config.h. It contains sensible defaults.")


write_makefile()
test_depends()

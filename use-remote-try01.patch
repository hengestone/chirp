diff --git a/doc/chirp_state_machine.ods b/doc/chirp_state_machine.ods
index 9e626a6..74cb073 100644
Binary files a/doc/chirp_state_machine.ods and b/doc/chirp_state_machine.ods differ
diff --git a/include/libchirp/message.h b/include/libchirp/message.h
index d110ef2..18b47c6 100644
--- a/include/libchirp/message.h
+++ b/include/libchirp/message.h
@@ -134,10 +134,11 @@ struct ch_message_s {
     int32_t        port;
     ch_chirp_t*    chirp;
     void*          user_data;
+    uint8_t        _last_err;
+    uint8_t        _tries;
     uint8_t        _flags;
     ch_send_cb_t   _send_cb;
-    void*          _conn;
-    int            _handler;
+    uint8_t        _handler;
     ch_message_t*  _next;
 };
 
diff --git a/mk/config.defs.h b/mk/config.defs.h
index 36c9b1f..85961a2 100644
--- a/mk/config.defs.h
+++ b/mk/config.defs.h
@@ -66,6 +66,12 @@
 
 #define CH_TCP_KEEPALIVE 60
 
+// Retry timeout (float) in seconds
+//
+// .. code-block:: cpp
+
+#define CH_RETRY_TIMEOUT 0.5
+
 // Log available ciphers. Used to debug connections failures.
 //
 // .. code-block:: cpp
diff --git a/src/chirp.c b/src/chirp.c
index d0fba0b..ff51921 100644
--- a/src/chirp.c
+++ b/src/chirp.c
@@ -888,7 +888,7 @@ ch_chirp_try_message_finish(
         );
 #   endif
         writer->flags = 0;
-        writer->msg = NULL;
+        // writer->msg = NULL; TODO dequeue message somewhere
         msg->_flags &= ~CH_MSG_USED;
         if(msg->_send_cb != NULL) {
             /* The user may free the message in the cb */
diff --git a/src/chirp.h b/src/chirp.h
index 07acf1e..3dac09c 100644
--- a/src/chirp.h
+++ b/src/chirp.h
@@ -60,9 +60,9 @@
 //            ch_buffer_pool_t
 //
 //    ch_remote_t (allows replacing connection to remote note)
+//       ch_writer_t
+//       ch_reader_t
 //        \*ch_connection_t (can be NULL)
-//            ch_writer_t
-//            ch_reader_t
 //        message-queue (-> ch_message_t)
 //
 //    ch_message_t
diff --git a/src/connection.c b/src/connection.c
index 878d3b5..516bb35 100644
--- a/src/connection.c
+++ b/src/connection.c
@@ -513,12 +513,8 @@ ch_cn_init(ch_chirp_t* chirp, ch_connection_t* conn, uint8_t flags)
 
     A(chirp->_init == CH_CHIRP_MAGIC, "Not a ch_chirp_t*");
     ch_chirp_int_t* ichirp  = chirp->_;
-    conn->load            = -1;
-    conn->chirp           = chirp;
     conn->flags          |= flags;
     conn->write_req.data  = conn;
-    ch_rd_init(&conn->reader);
-    ch_wr_init(&conn->writer, conn);
     tmp_err = uv_timer_init(ichirp->loop, &conn->shutdown_timeout);
     if(tmp_err != CH_SUCCESS) {
         EC(
@@ -712,7 +708,7 @@ ch_cn_shutdown(
     /* # TODO this should use ch_remote_t directly from function signature */
     ch_remote_t search_remote;
     ch_remote_t* remote;
-    ch_rm_init_from_conn(&search_remote, conn);
+    ch_rm_init_from_conn(chirp, &search_remote, conn);
     ch_rm_find(
         protocol->remotes,
         &search_remote,
diff --git a/src/connection.h b/src/connection.h
index 983676f..39bc2bb 100644
--- a/src/connection.h
+++ b/src/connection.h
@@ -37,11 +37,8 @@
 //    Check if a connection has been idle for RESUE_TIME seconds, since the
 //    connection is not valid: close it if needed and cleanup ch_remote_t.
 //
-// reco = reconnect
-//    Reconnect immediately.
-//
 // wait = wait
-//    Reconnect after waiting for TIMEOUT / 2 seconds.
+//    Reconnect after waiting for RETRY_TIMEOUT.
 //
 // clen = cleanup
 //    Cleanup data-structures and buffers, remove pointer to connection from
@@ -107,7 +104,7 @@
 // +-------------+--+--+--+-----+-----+-----+-----+-----+-----+------+-----+
 // |xxx          | 1| 1| 0| xxx | xxx | xxx | xxx | xxx | xxx | xxx  | xxx |
 // +-------------+--+--+--+-----+-----+-----+-----+-----+-----+------+-----+
-// |sending      | 1| 1| 1| enqu| send| dequ| send| reco| cing| chck | send|
+// |sending      | 1| 1| 1| enqu| send| dequ| send| wait| cing| chck | send|
 // |             |  |  |  |     |     |     | idle|     |     |      |     |
 // +-------------+--+--+--+-----+-----+-----+-----+-----+-----+------+-----+
 //
@@ -202,19 +199,6 @@ typedef enum {
 //
 //    Connection dictionary implemented as red-black tree.
 //
-//    .. c:member:: uint8_t ip_protocol
-//
-//       What IP protocol (IPv4 or IPv6) shall be used for connections.
-//
-//    .. c:member:: uint8_t[16] address
-//
-//       IPv4/6 address of the sender if the message was received.  IPv4/6
-//       address of the recipient if the message is going to be sent.
-//
-//    .. c:member:: int32_t port
-//
-//       The port that shall be used for connections.
-//
 //    .. c:member:: uint8_t[16] remote_identity
 //
 //       The identity of the remote target. This is used for getting the remote
@@ -337,41 +321,13 @@ typedef enum {
 //       connection and TLS handshakes. This is used within the protocol, see
 //       :c:func:`_ch_pr_do_handshake`.
 //
-//    .. c:member:: float load
-//
-//       The load of the remote peer. This is used when a protocol error or an
-//       timeout happens when writing. See :c:member:`ch_send_cb_t.load`.
-//
-//    .. c:member:: ch_reader_t reader
-//
-//       Handle to a chirp reader, handles handshakes and reads (buffers) on a
-//       connection.
-//
-//    .. c:member:: ch_writer_t writer
-//
-//       Handle to a chirp writer, handles sending and writing on a connection.
-//
-//    .. c:member:: char color_field
-//
-//       The color of the current (connection-) node. This may either be red or
-//       black, as connections are built as a red-black tree.
-//
-//    .. c:member:: ch_connection_t* left
-//
-//       (Struct-) Pointer to the left child of the current connection (node)
-//       in the red-black tree.
-//
-//    .. c:member:: ch_connection_t* right
+//    .. c:member:: ch_chirp_t* chirp
 //
-//       (Struct-) Pointer to the right child of the current connection (node)
-//       in the red-black tree.
+//       Pointer to the chirp object. See: :c:type:`ch_chirp_t`.
 //
 // .. code-block:: cpp
 //
 struct ch_connection_s {
-    uint8_t          ip_protocol;
-    uint8_t          address[CH_IP_ADDR_SIZE];
-    int32_t          port;
     uint8_t          remote_identity[CH_ID_SIZE];
     float            max_timeout;
     uv_tcp_t         client;
@@ -388,7 +344,6 @@ struct ch_connection_s {
     size_t           write_written;
     size_t           write_size;
     ch_buf*          write_buffer;
-    ch_chirp_t*      chirp;
     uv_shutdown_t    shutdown_req;
     uv_write_t       write_req;
     uv_timer_t       shutdown_timeout;
@@ -398,9 +353,7 @@ struct ch_connection_s {
     BIO*             bio_ssl;
     BIO*             bio_app;
     int              tls_handshake_state;
-    float            load;
-    ch_reader_t      reader;
-    ch_writer_t      writer;
+    ch_chirp_t*      chirp;
     ch_connection_t* next;
 };
 
diff --git a/src/reader.c b/src/reader.c
index 065895b..8befc59 100644
--- a/src/reader.c
+++ b/src/reader.c
@@ -188,7 +188,15 @@ _ch_rd_handshake(
         reader->hs.identity,
         sizeof(conn->remote_identity)
     );
-    ch_rm_init_from_conn(&search_remote, conn);
+    if(ch_rm_init_from_conn(chirp, &search_remote, conn) != CH_SHUTDOWN) {
+        EC(
+            chirp,
+            "Count not initialize remote -> shutdown. ", "ch_connection_t:%p",
+            (void*) conn
+        );
+        ch_cn_shutdown(conn, CH_PROTOCOL_ERROR);
+        return;
+    }
     if(ch_rm_find(protocol->remotes, &search_remote, &remote) != 0) {
         remote = ch_alloc(sizeof(ch_remote_t));
         *remote = search_remote;
diff --git a/src/remote.c b/src/remote.c
index 67c7d64..d3ccc90 100644
--- a/src/remote.c
+++ b/src/remote.c
@@ -23,17 +23,44 @@ rb_bind_impl_m(ch_rm, ch_remote_t)
 // .. code-block:: cpp
 
 // .. c:function::
-void
-ch_rm_init_from_msg(ch_remote_t* remote, ch_message_t* msg)
-//    :noindex:
+static
+ch_inline
+ch_error_t
+_ch_rm_init(
+        ch_chirp_t* chirp,
+        ch_remote_t* remote
+)
 //
-//    see: :c:func:`ch_rm_init_from_msg`
+//    Initialize remote
 //
 // .. code-block:: cpp
 //
 {
     memset(remote, 0, sizeof(ch_remote_t));
     ch_rm_node_init(remote);
+    remote->load  = -1;
+    remote->chirp = chirp;
+    ch_rd_init(&remote->reader);
+    return ch_wr_init(&remote->writer, conn); // TODO remote
+}
+
+// .. c:function::
+ch_error_t
+ch_rm_init_from_msg(
+        ch_chirp_t* chirp,
+        ch_remote_t* remote,
+        ch_message_t* msg
+)
+//    :noindex:
+//
+//    see: :c:func:`ch_rm_init_from_msg`
+//
+// .. code-block:: cpp
+//
+{
+    int tmp_err = _ch_rm_init(chirp, remote);
+    if(tmp_err != CH_SUCCESS)
+        return tmp_err;
     remote->ip_protocol = msg->ip_protocol;
     remote->port        = msg->port;
     memcpy(
@@ -45,8 +72,12 @@ ch_rm_init_from_msg(ch_remote_t* remote, ch_message_t* msg)
 }
 
 // .. c:function::
-void
-ch_rm_init_from_conn(ch_remote_t* remote, ch_connection_t* conn)
+ch_error_t
+ch_rm_init_from_conn(
+        ch_chirp_t* chirp,
+        ch_remote_t* remote,
+        ch_connection_t* conn
+)
 //    :noindex:
 //
 //    see: :c:func:`ch_rm_init_from_conn`
@@ -54,8 +85,9 @@ ch_rm_init_from_conn(ch_remote_t* remote, ch_connection_t* conn)
 // .. code-block:: cpp
 //
 {
-    memset(remote, 0, sizeof(ch_remote_t));
-    ch_rm_node_init(remote);
+    int tmp_err = _ch_rm_init(chirp, remote);
+    if(tmp_err != CH_SUCCESS)
+        return tmp_err;
     remote->ip_protocol = conn->ip_protocol;
     remote->port        = conn->port;
     memcpy(
diff --git a/src/remote.h b/src/remote.h
index f72bf58..4dbfc9d 100644
--- a/src/remote.h
+++ b/src/remote.h
@@ -28,6 +28,62 @@
 //
 //    .. c:member:: uint8_t ip_protocol
 //
+//       What IP protocol (IPv4 or IPv6) shall be used for connections.
+//
+//    .. c:member:: uint8_t[16] address
+//
+//       IPv4/6 address of the sender if the message was received.  IPv4/6
+//       address of the recipient if the message is going to be sent.
+//
+//    .. c:member:: int32_t port
+//
+//       The port that shall be used for connections.
+//
+//    .. c:member:: ch_connection_t* conn
+//
+//       The active connection to this remote. Can be NULL. Callbacks always
+//       have to check if the connection is NULL. The code that sets the
+//       connection to NULL has to initiate retry and notify the user. So
+//       callbacks can safely abort if conn is NULL.
+//
+//    .. c:member:: ch_message_t* msg_queue
+//
+//       The message queue, the head of this queue is the active message.
+//
+//    .. c:member:: ch_chirp_t* chirp
+//
+//       Pointer to the chirp object. See: :c:type:`ch_chirp_t`.
+//
+//    .. c:member:: float load
+//
+//       Last reported load of the remote
+//
+//    .. c:member:: ch_reader_t reader
+//
+//       Handle to a chirp reader, handles handshakes and reads (buffers) on a
+//       connection.
+//
+//    .. c:member:: ch_writer_t writer
+//
+//       Handle to a chirp writer, handles sending and writing on a connection.
+//
+//
+//    .. c:member:: char color
+//
+//       rbtree member
+//
+//    .. c:member:: ch_remote_t* left
+//
+//       rbtree member
+//
+//    .. c:member:: ch_remote_t* right
+//
+//       rbtree member
+//
+//    .. c:member:: ch_remote_t* parent
+//
+//       rbtree member
+//
 // .. code-block:: cpp
 //
 struct ch_remote_s {
@@ -35,6 +91,11 @@ struct ch_remote_s {
     uint8_t          address[CH_IP_ADDR_SIZE];
     int32_t          port;
     ch_connection_t* conn;
+    ch_message_t*    msg_queue;
+    ch_chirp_t*      chirp;
+    float            load;
+    ch_reader_t      reader;
+    ch_writer_t      writer;
     char             color;
     ch_remote_t*     parent;
     ch_remote_t*     left;
@@ -53,20 +114,30 @@ struct ch_remote_s {
 rb_bind_decl_m(ch_rm, ch_remote_t)
 
 // .. c:function::
-void
-ch_rm_init_from_msg(ch_remote_t* remote, ch_message_t* msg);
+ch_error_t
+ch_rm_init_from_msg(
+        ch_chirp_t* chirp,
+        ch_remote_t* remote,
+        ch_message_t* msg
+);
 //
 //    Initialize the remote data-structure from a message.
 //
+//    :param ch_chirp_t* chirp:   Pointer to chirp
 //    :param ch_remote_t* remote: Remote to initialize
 //    :param ch_message_t* msg:   Message to initialize from
 
 // .. c:function::
-void
-ch_rm_init_from_conn(ch_remote_t* remote, ch_connection_t* conn);
+ch_error_t
+ch_rm_init_from_conn(
+        ch_chirp_t* chirp,
+        ch_remote_t* remote,
+        ch_connection_t* conn
+);
 //
 //    Initialize the remote data-structure from a connection.
 //
+//    :param ch_chirp_t* chirp:   Pointer to chirp
 //    :param ch_remote_t* remote: Remote to initialize
 //    :param ch_connection_t*:   Connection to initialize from
 
diff --git a/src/writer.c b/src/writer.c
index 1c88311..41fcaf1 100644
--- a/src/writer.c
+++ b/src/writer.c
@@ -250,10 +250,10 @@ _ch_wr_connect_cb(uv_connect_t* req, int status)
 //
 {
     ch_text_address_t taddr;
-    ch_message_t* msg = req->data;
-    ch_chirp_t* chirp = msg->chirp;
+    ch_remote_t* remote = req->data;
+    ch_chirp_t* chirp = remote->chirp;
     A(chirp->_init == CH_CHIRP_MAGIC, "Not a ch_chirp_t*");
-    ch_connection_t* conn = msg->_conn;
+    ch_connection_t* conn = remote->conn;
     ch_msg_get_address(msg, &taddr);
     if(status == CH_SUCCESS) {
         LC(
@@ -264,7 +264,6 @@ _ch_wr_connect_cb(uv_connect_t* req, int status)
             (void*) conn
         );
         /* Here we join the code called on accept. */
-        conn->writer.send_msg = msg;
         ch_pr_conn_start(chirp, conn, &conn->client, 0);
     } else {
         EC(
@@ -284,7 +283,7 @@ _ch_wr_connect_cb(uv_connect_t* req, int status)
 
 // .. c:function::
 void
-ch_wr_write(ch_connection_t* conn, ch_message_t* msg)
+ch_wr_write(ch_remote_t* remote, ch_message_t* msg)
 //    :noindex:
 //
 //    see: :c:func:`ch_wr_write`
@@ -296,7 +295,6 @@ ch_wr_write(ch_connection_t* conn, ch_message_t* msg)
     A(chirp->_init == CH_CHIRP_MAGIC, "Not a ch_chirp_t*");
     ch_writer_t* writer = &conn->writer;
     ch_chirp_int_t* ichirp = chirp->_;
-    msg->_conn = conn;
     writer->flags = 0;
     A(writer->msg == NULL, "Message should be null on new write");
     writer->msg = msg;
@@ -598,15 +596,27 @@ ch_wr_send(ch_chirp_t* chirp, ch_message_t* msg, ch_send_cb_t send_cb)
     msg->_send_cb = send_cb;
     msg->_flags  |= CH_MSG_USED;
     ch_protocol_t* protocol = &ichirp->protocol;
-    ch_random_ints_as_bytes(msg->serial, sizeof(msg->serial));
 
-    ch_rm_init_from_msg(&search_remote, msg);
+    ch_rm_init_from_msg(chirp, &search_remote, msg);
     if(ch_rm_find(protocol->remotes, &search_remote, &remote) != 0) {
         remote = ch_alloc(sizeof(ch_remote_t));
         *remote = search_remote;
         tmp_err = ch_rm_insert(&protocol->remotes, remote);
         A(tmp_err == 0, "Inserting remote failed");
     }
+    if(msg->_tries > ichirp->config.RETRIES) {
+        msg->_tries = 0;
+        msg->_send_cb = NULL;
+        if(send_cb != NULL)
+            send_cb(msg, msg->_last_err, remote->load);
+        return msg->_last_err;
+    }
+    if(msg->_tries > 0) {
+        msg->_tries += 1;
+    } else
+        msg->_tries += 1;
+
+    ch_random_ints_as_bytes(msg->serial, sizeof(msg->serial));
     conn = remote->conn;
 
     if(conn == NULL) {
@@ -623,10 +633,7 @@ ch_wr_send(ch_chirp_t* chirp, ch_message_t* msg, ch_send_cb_t send_cb)
             return CH_ENOMEM;
         }
         memset(conn, 0, sizeof(ch_connection_t));
-        msg->_conn         = conn;
-        conn->port         = msg->port;
-        conn->ip_protocol  = msg->ip_protocol;
-        conn->connect.data = msg;
+        conn->connect.data = remote;
         ch_text_address_t taddr;
         ch_msg_get_address(msg, &taddr);
         if(!(
@@ -635,11 +642,6 @@ ch_wr_send(ch_chirp_t* chirp, ch_message_t* msg, ch_send_cb_t send_cb)
         )) {
             conn->flags |= CH_CN_ENCRYPTED;
         }
-        memcpy(
-            &conn->address,
-            &msg->address,
-            CH_IP_ADDR_SIZE
-        );
         uv_tcp_init(ichirp->loop, &conn->client);
         if(msg->ip_protocol == CH_IPV6) {
             struct sockaddr_in6 addr;
@@ -725,11 +727,12 @@ ch_wr_free(ch_writer_t* writer)
     ch_chirp_t* chirp = conn->chirp;
     A(chirp->_init == CH_CHIRP_MAGIC, "Not a ch_chirp_t*");
     uv_close((uv_handle_t*) &writer->send_timeout, ch_cn_close_cb);
-    conn->shutdown_tasks += 1;
+    uv_close((uv_handle_t*) &writer->retry_timeout, ch_cn_close_cb);
+    conn->shutdown_tasks += 2;
 }
 
 // .. c:function::
-void
+ch_error_t
 ch_wr_init(ch_writer_t* writer, ch_connection_t* conn)
 //    :noindex:
 //
@@ -750,6 +753,17 @@ ch_wr_init(ch_writer_t* writer, ch_connection_t* conn)
             "Initializing send timeout failed: %d",
             tmp_err
         );
+        return tmp_err;
     }
     writer->send_timeout.data = conn;
+    tmp_err = uv_timer_init(ichirp->loop, &writer->retry_timeout);
+    if(tmp_err != CH_SUCCESS) {
+        E(
+            chirp,
+            "Initializing retry timeout failed: %d",
+            tmp_err
+        );
+        return tmp_err;
+    }
+    return CH_SUCCESS;
 }
diff --git a/src/writer.h b/src/writer.h
index 531568a..4a27d69 100644
--- a/src/writer.h
+++ b/src/writer.h
@@ -65,10 +65,11 @@ typedef enum {
 //       message. At the end of the defined timeout time, the timer triggers
 //       the :c:func:`_ch_wr_write_timeout_cb` callback.
 //
-//    .. c:member:: ch_message_t* msg
+//    .. c:member:: uv_timer_t retry_timeout
 //
-//       Pointer to a message. The message is set when sending through
-//       :c:func:`ch_wr_write` and being read again during the callbacks.
+//       Libuv timer handle for setting a timeout when retrying to send a
+//       message. At the end of the defined timeout time, the timer triggers
+//       the :c:func:`_ch_wr_send_retry_cb` callback.
 //
 //    .. c:member:: ch_msg_message_t net_msg
 //
@@ -82,10 +83,6 @@ typedef enum {
 //       essentially only the identity, the serial number, the message type and
 //       the lengths of the header, the actor and the data.
 //
-//    .. c:member:: ch_message_t* msg
-//
-//       Pointer to the message that should be sent after handshake.
-//
 //    .. c:member:: char flags
 //
 //       Writer flags are CH_WR_ACK_RECEIVED, CH_WR_WRITE_DONE
@@ -94,9 +91,8 @@ typedef enum {
 //
 typedef struct ch_writer_s {
     uv_timer_t         send_timeout;
-    ch_message_t*      msg;
+    uv_timer_t         retry_timeout;
     ch_msg_message_t   net_msg;
-    ch_message_t*      send_msg;
     char               flags;
 } ch_writer_t;
 
@@ -110,7 +106,7 @@ ch_wr_free(ch_writer_t* writer);
 //
 
 // .. c:function::
-void
+ch_error_t
 ch_wr_init(ch_writer_t* writer, ch_connection_t* conn);
 //
 //    Initialize the writer data structure.
@@ -124,15 +120,13 @@ ch_wr_init(ch_writer_t* writer, ch_connection_t* conn);
 
 // .. c:function::
 void
-ch_wr_write(ch_connection_t* conn, ch_message_t* msg);
+ch_wr_write(ch_remote_t* conn, ch_message_t* msg);
 //
 //    Send the message after a connection has been established.
 //
-//    :param ch_connection_t* conn:  Connection to send the message over.
-//    :param ch_message_t msg:       The message to send. The memory of the
-//                                   message must stay valid until the callback
-//                                   is called.
-//
+//    :param ch_remote* remote: The remote so send the message to.
+//    :param ch_message_t msg:  The message to send. The memory of the message
+//                              must stay valid until the callback is called.
 //
 // .. c:function::
 int

diff --git a/include/libchirp/message.h b/include/libchirp/message.h
index c1d64ca..ec390da 100644
--- a/include/libchirp/message.h
+++ b/include/libchirp/message.h
@@ -122,7 +122,6 @@ struct ch_message_s {
     void*          user_data;
     uint8_t        _flags;
     ch_send_cb_t   _send_cb;
-    void*          _conn;
     int            _handler;
     ch_message_t*  _next;
 };
diff --git a/src/connection.h b/src/connection.h
index 1f73b6c..dd9161c 100644
--- a/src/connection.h
+++ b/src/connection.h
@@ -398,6 +398,7 @@ struct ch_connection_s {
     float            load;
     ch_reader_t      reader;
     ch_writer_t      writer;
+    ch_remote_t*     remote;
     ch_connection_t* next;
 };
 
diff --git a/src/message.c b/src/message.c
index 8120331..a920404 100644
--- a/src/message.c
+++ b/src/message.c
@@ -11,6 +11,18 @@
 #include "message.h"
 #include "util.h"
 
+// Definitions
+// ===========
+
+// Queue definition
+// ----------------
+//
+
+qs_queue_bind_impl_cx_m(ch_msg, ch_message_t)
+
+// Interface definitions
+// ---------------------
+
 // .. c:function::
 CH_EXPORT
 ch_error_t
diff --git a/src/message.h b/src/message.h
index 8af61b1..4f233aa 100644
--- a/src/message.h
+++ b/src/message.h
@@ -12,8 +12,15 @@
 // Project includes
 // ================
 #include "libchirp/message.h"
+#include "qs.h"
 
-// .. c:type:: ch_msg_type_t
+// Queue declarations
+// ==================
+//
+#define ch_msg_next_m(x) (x)->_next
+qs_queue_bind_decl_cx_m(ch_msg, ch_message_t)
+
+// .. c:type:: ch_msg_types_t
 //
 //    Represents message type flags.
 //
@@ -30,7 +37,7 @@
 typedef enum {
     CH_MSG_REQ_ACK = 1 << 0,
     CH_MSG_ACK     = 1 << 1,
-} ch_msg_type_t;
+} ch_msg_types_t;
 
 // .. c:type:: ch_msg_flags_t
 //
@@ -44,10 +51,6 @@ typedef enum {
 //
 //       Data has to be freed before releasing the buffer
 //
-//    .. c:member:: CH_MSG_QUEUED
-//
-//       The message is being queue
-//
 //    .. c:member:: CH_MSG_USED
 //
 //       The message is used by chirp
diff --git a/src/reader.c b/src/reader.c
index 9aad547..30ec6fd 100644
--- a/src/reader.c
+++ b/src/reader.c
@@ -253,6 +253,8 @@ _ch_rd_handle_msg(
 {
     ch_chirp_t* chirp = conn->chirp;
     A(chirp->_init == CH_CHIRP_MAGIC, "Not a ch_chirp_t*");
+    ch_remote_t* remote = conn->remote;
+    A(remote != NULL, "Remote should be set");
     ch_chirp_int_t* ichirp = chirp->_;
     /* Pause reading on last handler. */
     // TODO start reader again
@@ -280,15 +282,20 @@ _ch_rd_handle_msg(
         ack_msg->data_len   = 0;
         ack_msg->chirp      = chirp;
         ack_msg->port       = msg->port;
-        ack_msg->_conn      = msg->_conn;
         ch_random_ints_as_bytes(
             ack_msg->serial,
             sizeof(ack_msg->serial)
         );
-        ch_wr_send(chirp, ack_msg, NULL);
+        int queue_empty = remote->msg_queue == NULL;
+        // TODO this is not correct!
+        ch_msg_enqueue(&remote->msg_queue, ack_msg);
+        /* If there were no message in the we process the queue */
+        if(queue_empty)
+            ch_wr_process_queue(remote);
+
     } else if(msg->type & CH_MSG_ACK) {
         ch_writer_t* writer = &conn->writer;
-        if(memcmp(
+        if(memcmp( // TODO has to be last message
                 writer->msg->identity,
                 msg->identity,
                 CH_ID_SIZE
diff --git a/src/writer.c b/src/writer.c
index 32e6839..9c1d98f 100644
--- a/src/writer.c
+++ b/src/writer.c
@@ -195,10 +195,12 @@ void _ch_wr_close_failed_conn_cb(uv_handle_t* handle)
 // .. code-block:: cpp
 //
 {
-    ch_message_t* msg = handle->data;
+    ch_remote_t* remote = handle->data;
+    ch_message_t* msg;
+    ch_msg_head(remote->msg_queue, &msg);
     ch_chirp_t* chirp = msg->chirp;
     A(chirp->_init == CH_CHIRP_MAGIC, "Not a ch_chirp_t*");
-    ch_connection_t* conn = msg->_conn;
+    ch_connection_t* conn = remote->conn;
     ch_free(conn);
     msg->_flags &= ~CH_MSG_USED;
     if(msg->_send_cb != NULL) {
@@ -220,10 +222,15 @@ _ch_wr_connect_cb(uv_connect_t* req, int status)
 //
 {
     ch_text_address_t taddr;
-    ch_message_t* msg = req->data;
-    ch_chirp_t* chirp = msg->chirp;
+    ch_remote_t* remote = req->data;
+    ch_message_t* msg;
+    ch_msg_head(remote->msg_queue, &msg);
+    A(msg == NULL, "Queue should not be empty");
+    ch_chirp_t* chirp = remote->chirp;
+    A(chirp == NULL, "Chirp should be set");
     A(chirp->_init == CH_CHIRP_MAGIC, "Not a ch_chirp_t*");
-    ch_connection_t* conn = msg->_conn;
+    ch_connection_t* conn = remote->conn;
+    A(msg == NULL, "Connection should be set");
     ch_msg_get_address(msg, &taddr);
     if(status == CH_SUCCESS) {
         LC(
@@ -246,77 +253,12 @@ _ch_wr_connect_cb(uv_connect_t* req, int status)
             status,
             (void*) conn
         );
-        conn->client.data = msg;
+        conn->client.data = remote;
         uv_close((uv_handle_t*) &conn->client, _ch_wr_close_failed_conn_cb);
     }
 }
 
 
-// .. c:function::
-void
-ch_wr_write(ch_connection_t* conn, ch_message_t* msg)
-//    :noindex:
-//
-//    see: :c:func:`ch_wr_write`
-//
-// .. code-block:: cpp
-//
-{
-    ch_chirp_t* chirp = conn->chirp;
-    A(chirp->_init == CH_CHIRP_MAGIC, "Not a ch_chirp_t*");
-    ch_writer_t* writer = &conn->writer;
-    ch_chirp_int_t* ichirp = chirp->_;
-    msg->_conn = conn;
-    writer->flags = 0;
-    A(writer->msg == NULL, "Message should be null on new write");
-    writer->msg = msg;
-    int tmp_err = uv_timer_start(
-        &writer->send_timeout,
-        _ch_wr_write_timeout_cb,
-        ichirp->config.TIMEOUT * 1000,
-        0
-    );
-    if(tmp_err != CH_SUCCESS) {
-        EC(
-            chirp,
-            "Starting send timeout failed: %d. ", "ch_connection_t:%p",
-            tmp_err,
-            (void*) conn
-        );
-    }
-
-// Use the writers net message structure to write the actual message over
-// the connection. The net message structure is of type
-// :c:type:`ch_msg_message_t`, which is actually :c:macro:`CH_WIRE_MESSAGE`.
-// The difference between ``msg`` and ``net_msg`` is, that ``msg`` is of
-// type :c:type:`ch_message_t` and ``net_msg`` of type
-// :c:macro:`CH_WIRE_MESSAGE`. That means ``net_msg`` is stripped down to
-// essentially only the identity, the serial number, the message type and
-// the lengths of the header and the data.
-//
-// .. code-block:: cpp
-//
-    ch_msg_message_t* net_msg = &writer->net_msg;
-    memcpy(
-        net_msg->serial,
-        msg->serial,
-        sizeof(net_msg->serial)
-    );
-    memcpy(
-        net_msg->identity,
-        msg->identity,
-        sizeof(net_msg->identity)
-    );
-    net_msg->type         = msg->type;
-    net_msg->header_len   = htons(msg->header_len);
-    net_msg->data_len     = htonl(msg->data_len);
-    ch_cn_write(
-        conn,
-        net_msg,
-        sizeof(ch_msg_message_t),
-        _ch_wr_write_msg_header_cb
-    );
-}
 
 // .. c:function::
 static
@@ -502,39 +444,95 @@ ch_chirp_send(ch_chirp_t* chirp, ch_message_t* msg, ch_send_cb_t send_cb)
 }
 
 // .. c:function::
+CH_EXPORT
 int
-ch_wr_send(ch_chirp_t* chirp, ch_message_t* msg, ch_send_cb_t send_cb)
+ch_chirp_send_ts(ch_chirp_t* chirp, ch_message_t* msg, ch_send_cb_t send_cb)
 //    :noindex:
 //
-//    see: :c:func:`ch_wr_send`
+//    see: :c:func:`ch_chirp_send_ts`
 //
 // .. code-block:: cpp
 //
 {
     A(chirp->_init == CH_CHIRP_MAGIC, "Not a ch_chirp_t*");
-    ch_chirp_int_t* ichirp  = chirp->_;
-    if(ichirp->flags & CH_CHIRP_CLOSING || ichirp->flags & CH_CHIRP_CLOSED) {
-        if(send_cb != NULL)
-            send_cb(msg, CH_SHUTDOWN, -1);
-        return CH_SHUTDOWN;
+    ch_chirp_int_t* ichirp = chirp->_;
+    uv_mutex_lock(&ichirp->send_ts_queue_lock);
+    if(msg->_flags & CH_MSG_USED) {
+        EC(
+            chirp,
+            "Message already used. ", "ch_message_t:%p",
+            (void*) msg
+        );
+        return CH_USED;
     }
-    int tmp_err;
-    ch_remote_t      search_remote;
-    ch_remote_t*     remote;
-    ch_connection_t* conn;
     msg->_send_cb = send_cb;
-    msg->_flags  |= CH_MSG_USED;
-    ch_protocol_t* protocol = &ichirp->protocol;
-    ch_random_ints_as_bytes(msg->serial, sizeof(msg->serial));
+    ch_mq_enqueue(&ichirp->send_ts_queue, msg);
+    uv_mutex_unlock(&ichirp->send_ts_queue_lock);
+    uv_async_send(&ichirp->send_ts);
+    return CH_SUCCESS;
+}
 
-    ch_rm_init_from_msg(chirp, &search_remote, msg);
-    if(ch_rm_find(protocol->remotes, &search_remote, &remote) != 0) {
-        remote = ch_alloc(sizeof(ch_remote_t));
-        *remote = search_remote;
-        tmp_err = ch_rm_insert(&protocol->remotes, remote);
-        A(tmp_err == 0, "Inserting remote failed");
+// .. c:function::
+void
+ch_wr_free(ch_writer_t* writer)
+//    :noindex:
+//
+//    see: :c:func:`ch_wr_free`
+//
+// .. code-block:: cpp
+//
+{
+    ch_connection_t* conn = writer->send_timeout.data;
+    ch_chirp_t* chirp = conn->chirp;
+    A(chirp->_init == CH_CHIRP_MAGIC, "Not a ch_chirp_t*");
+    uv_close((uv_handle_t*) &writer->send_timeout, ch_cn_close_cb);
+    conn->shutdown_tasks += 1;
+}
+
+// .. c:function::
+void
+ch_wr_init(ch_writer_t* writer, ch_connection_t* conn)
+//    :noindex:
+//
+//    see: :c:func:`ch_wr_init`
+//
+// .. code-block:: cpp
+//
+{
+    int tmp_err;
+
+    ch_chirp_t* chirp = conn->chirp;
+    A(chirp->_init == CH_CHIRP_MAGIC, "Not a ch_chirp_t*");
+    ch_chirp_int_t* ichirp = chirp->_;
+    tmp_err = uv_timer_init(ichirp->loop, &writer->send_timeout);
+    if(tmp_err != CH_SUCCESS) {
+        E(
+            chirp,
+            "Initializing send timeout failed: %d",
+            tmp_err
+        );
     }
-    conn = remote->conn;
+    writer->send_timeout.data = conn;
+}
+
+// .. c:function::
+int
+ch_wr_process_queue(ch_remote_t* remote)
+//    :noindex:
+//
+//    see: :c:func:`ch_wr_process_queue`
+//
+// .. code-block:: cpp
+//
+{
+    int tmp_err;
+
+    ch_connection_t* conn = remote->conn;
+    ch_chirp_t* chirp = conn->chirp;
+    A(chirp->_init == CH_CHIRP_MAGIC, "Not a ch_chirp_t*");
+    ch_chirp_int_t* ichirp = chirp->_;
+    ch_message_t* msg;
+    ch_msg_head(remote->msg_queue, &msg);
 
     if(conn == NULL) {
         conn = ch_alloc(sizeof(ch_connection_t));
@@ -545,15 +543,17 @@ ch_wr_send(ch_chirp_t* chirp, ch_message_t* msg, ch_send_cb_t send_cb)
                 "Could not allocate memory for connection%s", ""
             );
             msg->_flags &= ~CH_MSG_USED;
-            if(send_cb != NULL)
-                send_cb(msg, CH_ENOMEM, -1);
+            if(msg->_send_cb != NULL) {
+                ch_send_cb_t cb = msg->_send_cb;
+                msg->_send_cb = NULL;
+                cb(msg, CH_ENOMEM, remote->load);
+            }
             return CH_ENOMEM;
         }
         memset(conn, 0, sizeof(ch_connection_t));
-        msg->_conn         = conn;
         conn->port         = msg->port;
         conn->ip_protocol  = msg->ip_protocol;
-        conn->connect.data = msg;
+        conn->connect.data = remote;
         ch_text_address_t taddr;
         ch_msg_get_address(msg, &taddr);
         if(!(
@@ -610,73 +610,108 @@ ch_wr_send(ch_chirp_t* chirp, ch_message_t* msg, ch_send_cb_t send_cb)
 }
 
 // .. c:function::
-CH_EXPORT
 int
-ch_chirp_send_ts(ch_chirp_t* chirp, ch_message_t* msg, ch_send_cb_t send_cb)
+ch_wr_send(ch_chirp_t* chirp, ch_message_t* msg, ch_send_cb_t send_cb)
 //    :noindex:
 //
-//    see: :c:func:`ch_chirp_send_ts`
+//    see: :c:func:`ch_wr_send`
 //
 // .. code-block:: cpp
 //
 {
     A(chirp->_init == CH_CHIRP_MAGIC, "Not a ch_chirp_t*");
-    ch_chirp_int_t* ichirp = chirp->_;
-    uv_mutex_lock(&ichirp->send_ts_queue_lock);
-    if(msg->_flags & CH_MSG_USED) {
-        EC(
-            chirp,
-            "Message already used. ", "ch_message_t:%p",
-            (void*) msg
-        );
-        return CH_USED;
+    ch_chirp_int_t* ichirp  = chirp->_;
+    if(ichirp->flags & CH_CHIRP_CLOSING || ichirp->flags & CH_CHIRP_CLOSED) {
+        if(send_cb != NULL)
+            send_cb(msg, CH_SHUTDOWN, -1);
+        return CH_SHUTDOWN;
     }
+    int tmp_err;
+    ch_remote_t      search_remote;
+    ch_remote_t*     remote;
     msg->_send_cb = send_cb;
-    ch_mq_enqueue(&ichirp->send_ts_queue, msg);
-    uv_mutex_unlock(&ichirp->send_ts_queue_lock);
-    uv_async_send(&ichirp->send_ts);
-    return CH_SUCCESS;
-}
+    msg->_flags  |= CH_MSG_USED;
+    ch_protocol_t* protocol = &ichirp->protocol;
+    ch_random_ints_as_bytes(msg->serial, sizeof(msg->serial));
 
-// .. c:function::
-void
-ch_wr_free(ch_writer_t* writer)
-//    :noindex:
-//
-//    see: :c:func:`ch_wr_free`
-//
-// .. code-block:: cpp
-//
-{
-    ch_connection_t* conn = writer->send_timeout.data;
-    ch_chirp_t* chirp = conn->chirp;
-    A(chirp->_init == CH_CHIRP_MAGIC, "Not a ch_chirp_t*");
-    uv_close((uv_handle_t*) &writer->send_timeout, ch_cn_close_cb);
-    conn->shutdown_tasks += 1;
+    ch_rm_init_from_msg(chirp, &search_remote, msg);
+    if(ch_rm_find(protocol->remotes, &search_remote, &remote) != 0) {
+        remote = ch_alloc(sizeof(ch_remote_t));
+        *remote = search_remote;
+        tmp_err = ch_rm_insert(&protocol->remotes, remote);
+        A(tmp_err == 0, "Inserting remote failed");
+    }
+    int queue_empty = remote->msg_queue == NULL;
+    ch_msg_enqueue(&remote->msg_queue, msg);
+    /* If there were no message in the queue, process the queue, otherwise
+     * return */
+    if(queue_empty)
+        return ch_wr_process_queue(remote);
+    else
+        return CH_QUEUED;
 }
 
 // .. c:function::
 void
-ch_wr_init(ch_writer_t* writer, ch_connection_t* conn)
+ch_wr_write(ch_connection_t* conn, ch_message_t* msg)
 //    :noindex:
 //
-//    see: :c:func:`ch_wr_init`
+//    see: :c:func:`ch_wr_write`
 //
 // .. code-block:: cpp
 //
 {
-    int tmp_err;
-
     ch_chirp_t* chirp = conn->chirp;
     A(chirp->_init == CH_CHIRP_MAGIC, "Not a ch_chirp_t*");
+    ch_writer_t* writer = &conn->writer;
     ch_chirp_int_t* ichirp = chirp->_;
-    tmp_err = uv_timer_init(ichirp->loop, &writer->send_timeout);
+    writer->flags = 0;
+    A(writer->msg == NULL, "Message should be null on new write");
+    writer->msg = msg;
+    int tmp_err = uv_timer_start(
+        &writer->send_timeout,
+        _ch_wr_write_timeout_cb,
+        ichirp->config.TIMEOUT * 1000,
+        0
+    );
     if(tmp_err != CH_SUCCESS) {
-        E(
+        EC(
             chirp,
-            "Initializing send timeout failed: %d",
-            tmp_err
+            "Starting send timeout failed: %d. ", "ch_connection_t:%p",
+            tmp_err,
+            (void*) conn
         );
     }
-    writer->send_timeout.data = conn;
+
+// Use the writers net message structure to write the actual message over
+// the connection. The net message structure is of type
+// :c:type:`ch_msg_message_t`, which is actually :c:macro:`CH_WIRE_MESSAGE`.
+// The difference between ``msg`` and ``net_msg`` is, that ``msg`` is of
+// type :c:type:`ch_message_t` and ``net_msg`` of type
+// :c:macro:`CH_WIRE_MESSAGE`. That means ``net_msg`` is stripped down to
+// essentially only the identity, the serial number, the message type and
+// the lengths of the header and the data.
+//
+// .. code-block:: cpp
+//
+    ch_msg_message_t* net_msg = &writer->net_msg;
+    memcpy(
+        net_msg->serial,
+        msg->serial,
+        sizeof(net_msg->serial)
+    );
+    memcpy(
+        net_msg->identity,
+        msg->identity,
+        sizeof(net_msg->identity)
+    );
+    net_msg->type         = msg->type;
+    net_msg->header_len   = htons(msg->header_len);
+    net_msg->data_len     = htonl(msg->data_len);
+    ch_cn_write(
+        conn,
+        net_msg,
+        sizeof(ch_msg_message_t),
+        _ch_wr_write_msg_header_cb
+    );
 }
diff --git a/src/writer.h b/src/writer.h
index d683df1..52f7258 100644
--- a/src/writer.h
+++ b/src/writer.h
@@ -123,17 +123,15 @@ ch_wr_init(ch_writer_t* writer, ch_connection_t* conn);
 //    :param ch_connection_t* conn:  Pointer to a connection instance.
 
 // .. c:function::
-void
-ch_wr_write(ch_connection_t* conn, ch_message_t* msg);
-//
-//    Send the message after a connection has been established.
-//
-//    :param ch_connection_t* conn:  Connection to send the message over.
-//    :param ch_message_t msg:       The message to send. The memory of the
-//                                   message must stay valid until the callback
-//                                   is called.
+int
+ch_wr_process_queue(ch_remote_t* remote);
 //
+//    Process the message queue of a remote. Send the next available message.
+//    Doesn't do a dequeued, since a message is only dequeud after successful
+//    send.
 //
+//    :param ch_remote_t: The remote to process.
+
 // .. c:function::
 int
 ch_wr_send(ch_chirp_t* chirp, ch_message_t* msg, ch_send_cb_t send_cb);
@@ -150,5 +148,18 @@ _ch_wr_send_ts_cb(uv_async_t* handle);
 //
 //    :param uv_async_t* handle: Async handler used to trigger sending message
 //                               queue.
+//
+// .. c:function::
+void
+ch_wr_write(ch_connection_t* conn, ch_message_t* msg);
+//
+//    Send the message after a connection has been established.
+//
+//    :param ch_connection_t* conn:  Connection to send the message over.
+//    :param ch_message_t msg:       The message to send. The memory of the
+//                                   message must stay valid until the callback
+//                                   is called.
+//
+//
 
 #endif //ch_writer_h
